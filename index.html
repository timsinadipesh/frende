<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>frende</title>
<style>
  :root {
    --bg-color: #f8f9fa;
    --text-color: #1a1a1a;
    --panel-bg: #ffffff;
    --message-human: #0066cc;
    --message-ai: #f5f5f5;
    --accent-color: #0066cc;
    --recording-color: #f44336;
    --success-color: #4caf50;
    --border-color: #e5e5e5;
  }
  [data-theme="dark"] {
    --bg-color: #121212;
    --text-color: #ffffff;
    --panel-bg: #1e1e1e;
    --message-human: #0066cc;
    --message-ai: rgba(255,255,255,0.1);
    --accent-color: #64b5f6;
    --recording-color: #ef5350;
    --success-color: #66bb6a;
    --border-color: rgba(255,255,255,0.1);
  }

  * { 
    margin: 0;
    padding: 0;
    box-sizing: border-box; 
  }
  
  body {
    font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", Inter, system-ui, sans-serif;
    height: 100vh;
    display: flex;
    flex-direction: column;
    background: var(--bg-color);
    color: var(--text-color);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  .top-bar {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    gap: 12px;
    padding: 12px;
    background: var(--panel-bg);
    border-bottom: 1px solid var(--border-color);
  }
  .left-group {
    display: flex;
    align-items: center;
    gap: 10px;
    justify-self: start;
  }
  .brand {
    font-weight: 700;
    font-size: 1.25rem;
    letter-spacing: .4px;
    justify-self: center;
    user-select: none;
  }
  .right-group { 
    justify-self: end; 
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .lang-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 8px 12px;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    cursor: pointer;
    background: var(--bg-color);
    color: var(--text-color);
    transition: all .15s ease;
    font-weight: 600;
    letter-spacing: .3px;
    white-space: nowrap;
    position: relative;
  }
  .lang-btn:hover { 
    background: rgba(0,0,0,0.05);
    border-color: rgba(0,0,0,0.2);
  }

  .theme-toggle {
    display: flex;
    gap: 2px;
    background: var(--panel-bg);
    border-radius: 6px;
    padding: 2px;
    border: 1px solid var(--border-color);
  }

  .theme-btn {
    padding: 4px 8px;
    border: none;
    background: transparent;
    color: var(--text-color);
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.8rem;
    font-weight: 500;
    transition: all .15s ease;
  }

  .theme-btn.active {
    background: var(--bg-color);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }

  .theme-btn:hover:not(.active) {
    background: rgba(0,0,0,0.05);
  }

  .main { 
    flex: 1; 
    display: flex;
    flex-direction: column;
    overflow: hidden; 
    max-width: 1000px;
    margin: 0 auto;
    width: 100%;
  }
  
  .chat-history {
    flex: 1;
    overflow-y: auto;
    padding: 24px;
    display: flex;
    flex-direction: column;
    gap: 20px;
    background: var(--bg-color);
  }

  .welcome-message {
    text-align: center;
    color: #666666;
    padding: 60px 20px;
    font-size: 16px;
    line-height: 1.6;
    font-weight: 400;
  }

  .welcome-message p:first-child {
    font-size: 18px;
    font-weight: 500;
    color: var(--text-color);
    margin-bottom: 8px;
  }

  .message {
    display: flex;
    gap: 12px;
    align-items: flex-start;
    max-width: 90%;
    position: relative;
  }
  
  .message.from-human {
    align-self: flex-end;
    flex-direction: row-reverse;
  }
  
  .message.from-ai {
    align-self: flex-start;
  }
  
  .message-content {
    padding: 16px 20px;
    border-radius: 18px;
    line-height: 1.5;
    word-wrap: break-word;
    font-size: 16px;
    white-space: pre-wrap;
    position: relative;
    min-width: 200px;
  }

  .message.from-human .message-content {
    background: var(--message-human);
    color: #ffffff;
  }

  .message.from-ai .message-content {
    background: var(--message-ai);
    color: var(--text-color);
    white-space: normal;
  }

  .message.transcribed {
    border-left: 3px solid var(--accent-color);
    padding-left: 15px;
  }

  .message-actions {
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity .2s ease;
    margin-top: 8px;
  }
  
  .message:hover .message-actions {
    opacity: 1;
  }

  .message.from-human .message-actions {
    justify-content: flex-end;
  }

  .message.from-ai .message-actions {
    justify-content: flex-start;
  }

  .play-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: 1px solid var(--accent-color);
    background: var(--panel-bg);
    color: var(--accent-color);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    transition: all .2s ease;
    flex-shrink: 0;
  }

  .play-btn:hover {
    background: var(--accent-color);
    color: var(--panel-bg);
    transform: scale(1.1);
  }

  .play-btn.playing {
    background: var(--success-color);
    border-color: var(--success-color);
    color: white;
    animation: pulse-play 1s infinite;
  }

  .play-btn.loading {
    animation: spin 1s linear infinite;
  }

  @keyframes pulse-play {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  /* Input Section Styles */
  .input-section {
    flex-shrink: 0;
    width: 100%;
    background: var(--bg-color);
    padding: 20px 24px;
    max-width: 1000px;
    margin: 0 auto;
  }

  .attachments {
    display: none;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 16px;
  }

  .attachments.active {
    display: flex;
  }

  .attachment-pill {
    display: flex;
    align-items: center;
    background: var(--message-ai);
    padding: 8px 12px;
    border-radius: 16px;
    font-size: 14px;
    color: var(--text-color);
    border: 1px solid var(--border-color);
  }

  .attachment-pill span {
    max-width: 150px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .remove-attachment {
    background: none;
    border: none;
    cursor: pointer;
    padding: 0 0 0 8px;
    color: #999999;
    font-size: 16px;
    line-height: 1;
  }

  .remove-attachment:hover {
    color: #666666;
  }

  .input-container {
    position: relative;
    width: 80%;
    margin: 0 auto;
  }

  .input-field {
    width: 100%;
    min-height: 56px;
    max-height: 120px;
    padding: 16px 120px 16px 20px;
    font-size: 16px;
    font-family: inherit;
    border: 2px solid var(--border-color);
    border-radius: 28px;
    resize: none;
    background: var(--panel-bg);
    color: var(--text-color);
    transition: all 200ms ease;
    line-height: 1.4;
    outline: none;
  }

  .input-field:focus {
    border-color: var(--accent-color);
    border-width: 2px;
  }

  .input-field::placeholder {
    color: #999999;
  }

  .input-controls {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .control-button {
    width: 40px;
    height: 40px;
    background: none;
    border: none;
    border-radius: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 200ms ease;
    font-size: 16px;
  }

  .control-button:hover {
    background: rgba(0,0,0,0.05);
  }

  .control-button:disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }

  .control-button:disabled:hover {
    background: none;
  }

  .control-button svg {
    width: 20px;
    height: 20px;
    fill: #666666;
  }

  /* Updated Send Button and Voice Mode Button Styles */
  .send-voice-container {
    position: relative;
  }

  .send-button {
    background: var(--accent-color);
    position: relative;
    z-index: 2;
  }

  .send-button:hover:not(:disabled) {
    background: #0056b3;
  }

  .send-button svg {
    fill: #ffffff;
  }

  .send-button:disabled {
    background: var(--border-color);
  }

  .send-button:disabled svg {
    fill: #999999;
  }

  /* Removed attachment button styles */

  .recording {
    background: var(--recording-color) !important;
  }

  .recording svg {
    fill: #ffffff !important;
  }

  /* Voice Mode Button Styles */
  .voice-mode-btn {
    background: var(--accent-color);
    color: white;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1;
    opacity: 1;
    transition: opacity 200ms ease;
  }

  .voice-mode-btn:hover {
    background: #0056b3;
  }

  .voice-mode-btn svg {
    fill: white;
  }

  .voice-mode-btn.active {
    background: var(--recording-color);
    animation: pulse 1.5s infinite;
  }

  .voice-mode-btn.active:hover {
    background: var(--recording-color);
  }

  .voice-mode-btn.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .send-button.hidden {
    opacity: 0;
    pointer-events: none;
  }

  /* Frequency bars animation */
  .frequency-bars {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 2px;
    width: 20px;
    height: 20px;
  }

  .frequency-bar {
    width: 2px;
    background: currentColor;
    border-radius: 1px;
    animation: frequency 0.8s infinite ease-in-out;
  }

  .frequency-bar:nth-child(1) { height: 8px; animation-delay: 0s; }
  .frequency-bar:nth-child(2) { height: 12px; animation-delay: 0.1s; }
  .frequency-bar:nth-child(3) { height: 16px; animation-delay: 0.2s; }
  .frequency-bar:nth-child(4) { height: 12px; animation-delay: 0.3s; }
  .frequency-bar:nth-child(5) { height: 8px; animation-delay: 0.4s; }

  @keyframes frequency {
    0%, 40%, 100% { transform: scaleY(0.3); }
    20% { transform: scaleY(1); }
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }

  #file-input {
    display: none;
  }

  .modal {
    position: fixed;
    inset: 0;
    z-index: 1000;
    background: rgba(0,0,0,0.35);
    display: none;
    align-items: center;
    justify-content: center;
  }
  .card {
    width: min(280px, 92vw);
    background: #ffffff;
    color: #000;
    border-radius: 16px;
    padding: 18px 16px;
    box-shadow: 0 18px 60px rgba(0,0,0,0.25);
  }
  .chips {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .chip {
    padding: 12px 16px;
    text-align: center;
    border-radius: 12px;
    background: #f2f5fb;
    border: 1px solid #e4eaf2;
    cursor: pointer;
    user-select: none;
    font-weight: 600;
    color: #102038;
    transition: background .15s ease, border-color .15s ease, color .15s ease;
  }
  .chip:hover {
    background: #e3e9f3;
    border-color: #c5d1e4;
  }
  .chip.active {
    background: #bbdefb;
    border-color: #2196f3;
    color: #0d47a1;
  }

  .status {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: var(--panel-bg);
    color: var(--text-color);
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 0.9rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    border: 1px solid var(--border-color);
    opacity: 0;
    transition: opacity .3s ease;
    z-index: 100;
  }

  .status.show {
    opacity: 1;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .main {
      max-width: 100%;
    }
    
    .message {
      max-width: 95%;
    }
    
    .input-field {
      padding: 14px 100px 14px 20px;
      min-height: 48px;
    }

    .input-container {
      width: 95%;
    }
  }

  /* Scrollbar styling */
  .chat-history::-webkit-scrollbar {
    width: 8px;
  }

  .chat-history::-webkit-scrollbar-track {
    background: var(--bg-color);
  }

  .chat-history::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 4px;
  }

  .chat-history::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
  }
</style>
</head>
<body>

  <div class="top-bar">
    <div class="left-group">
      <button id="lang-btn" class="lang-btn" title="Select Language" aria-label="Select Language">
        <span id="selected-lang">EN â†’ DE</span>
      </button>
    </div>
    <div class="brand">frende</div>
    <div class="right-group">
      <div class="theme-toggle">
        <button id="theme-light" class="theme-btn">Light</button>
        <button id="theme-dark" class="theme-btn">Dark</button>
      </div>
    </div>
  </div>

  <div class="main">
    <div class="chat-history" id="chat-history">
      <div class="welcome-message">
        <p>Welcome to frende</p>
        <p>let there be no language barriers</p>
      </div>
    </div>

    <!-- New Input Section -->
    <div class="input-section">      
      <div class="input-container">        
        <textarea
          id="message-input"
          class="input-field"
          placeholder="Type your message..."
          rows="1"
        ></textarea>
        
        <div class="input-controls">
          <button class="control-button" id="mic-btn" title="Record audio">
            <svg viewBox="0 0 24 24">
              <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.49 6-3.31 6-6.72h-1.7z"/>
            </svg>
          </button>
          
          <div class="send-voice-container">
            <button class="control-button send-button hidden" id="send-btn" title="Send message">
              <svg viewBox="0 0 24 24" id="send-icon">
                <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
              </svg>
            </button>
            
            <button class="control-button voice-mode-btn" id="voice-mode-btn" title="Voice mode - continuous conversation">
              <div class="frequency-bars">
                <div class="frequency-bar"></div>
                <div class="frequency-bar"></div>
                <div class="frequency-bar"></div>
                <div class="frequency-bar"></div>
                <div class="frequency-bar"></div>
              </div>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="lang-modal" class="modal">
    <div class="card">
      <div class="chips" id="lang-chips">
        <div class="chip" data-pair="EN â†’ DE">EN â†’ DE</div>
        <div class="chip" data-pair="DE â†’ FR">DE â†’ FR</div>
        <div class="chip" data-pair="FR â†’ EN">FR â†’ EN</div>
      </div>
    </div>
  </div>

  <div id="status" class="status"></div>

<script>
  const chatHistory = document.getElementById('chat-history');
  const langBtn = document.getElementById('lang-btn');
  const selectedLangLabel = document.getElementById('selected-lang');
  const modal = document.getElementById('lang-modal');
  const chips = document.getElementById('lang-chips');
  const themeLightBtn = document.getElementById('theme-light');
  const themeDarkBtn = document.getElementById('theme-dark');
  const status = document.getElementById('status');
  
  // New input elements
  const messageInput = document.getElementById('message-input');
  const sendBtn = document.getElementById('send-btn');
  const sendIcon = document.getElementById('send-icon');
  const micBtn = document.getElementById('mic-btn');
  const voiceModeBtn = document.getElementById('voice-mode-btn');

  const API_BASE = 'http://localhost:5000';

  const LANGUAGE_PAIRS = {
    'EN â†’ DE': 'EN â†’ DE',
    'DE â†’ FR': 'DE â†’ FR', 
    'FR â†’ EN': 'FR â†’ EN'
  };

  let currentLangPair = 'EN â†’ DE';
  let mediaRecorder = null;
  let audioChunks = [];
  let isRecording = false;
  let mediaStream = null;
  let currentlyPlayingAudio = null;
  let currentlyPlayingButton = null;
  let isVoiceMode = false;
  let voiceModeActive = false;

  function showStatus(message) {
    status.textContent = message;
    status.classList.add('show');
    setTimeout(() => {
      status.classList.remove('show');
    }, 3000);
  }

  function getSystemTheme() {
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  }

  function applyTheme(theme) {
    document.documentElement.dataset.theme = theme;
    themeLightBtn.classList.toggle('active', theme === 'light');
    themeDarkBtn.classList.toggle('active', theme === 'dark');
  }

  function loadSettings() {
    const savedLang = localStorage.getItem('langPair');
    const savedTheme = localStorage.getItem('theme');

    if (savedLang && LANGUAGE_PAIRS[savedLang]) {
      currentLangPair = savedLang;
    }
    selectedLangLabel.textContent = currentLangPair;

    const themeToApply = savedTheme || getSystemTheme();
    applyTheme(themeToApply);

    chips.querySelectorAll('.chip').forEach(chip => {
      chip.classList.toggle('active', chip.dataset.pair === currentLangPair);
    });
  }

  function saveSettings() {
    localStorage.setItem('langPair', currentLangPair);
  }

  function saveTheme(theme) {
    localStorage.setItem('theme', theme);
  }

  function openLangModal() { modal.style.display = 'flex'; }
  function closeLangModal() { 
    modal.style.display = 'none'; 
    messageInput.focus(); 
  }

  // Auto-resize textarea function
  function autoResizeTextarea() {
    messageInput.style.height = 'auto';
    
    const maxHeight = 120;
    if (messageInput.scrollHeight > maxHeight) {
      messageInput.style.height = maxHeight + 'px';
      messageInput.style.overflowY = 'auto';
    } else {
      messageInput.style.height = messageInput.scrollHeight + 'px';
      messageInput.style.overflowY = 'hidden';
    }
  }

  // Update send button function
  function updateSendButton() {
    const hasText = messageInput.value.trim().length > 0;
    const hasContent = hasText;
    
    if (hasContent) {
      sendBtn.classList.remove('hidden');
      sendBtn.disabled = false;
      voiceModeBtn.classList.add('hidden');
    } else {
      sendBtn.classList.add('hidden');
      sendBtn.disabled = true;
      voiceModeBtn.classList.remove('hidden');
    }
  }

  // Voice mode functions
  function toggleVoiceMode() {
    if (isVoiceMode) {
      stopVoiceMode();
    } else {
      startVoiceMode();
    }
  }

  function startVoiceMode() {
    isVoiceMode = true;
    voiceModeActive = true;
    voiceModeBtn.classList.add('active');
    startRecording();
    showStatus('Voice mode activated - speak to begin');
  }

  function stopVoiceMode() {
    isVoiceMode = false;
    voiceModeActive = false;
    voiceModeBtn.classList.remove('active');
    
    if (isRecording) {
      stopRecording();
    }
    if (currentlyPlayingAudio) {
      currentlyPlayingAudio.pause();
      currentlyPlayingAudio.currentTime = 0;
      if (currentlyPlayingButton) {
        currentlyPlayingButton.classList.remove('playing');
        currentlyPlayingButton.textContent = 'ðŸ”Š';
        currentlyPlayingButton = null;
      }
      currentlyPlayingAudio = null;
    }
    
    showStatus('Voice mode deactivated');
  }

  // Render attachments
  function renderAttachments() {
    attachmentDisplay.innerHTML = '';
    
    if (attachedFiles.size === 0) {
      attachmentDisplay.classList.remove('active');
      return;
    }
    
    attachmentDisplay.classList.add('active');
    
    attachedFiles.forEach((file, name) => {
      const pill = document.createElement('div');
      pill.className = 'attachment-pill';
      
      const span = document.createElement('span');
      span.textContent = name;
      
      const btn = document.createElement('button');
      btn.className = 'remove-attachment';
      btn.textContent = 'Ã—';
      btn.onclick = () => {
        attachedFiles.delete(name);
        renderAttachments();
        updateSendButton();
      };
      
      pill.appendChild(span);
      pill.appendChild(btn);
      attachmentDisplay.appendChild(pill);
    });
  }

  // Event listeners
  langBtn.addEventListener('click', openLangModal);

  chips.addEventListener('click', e => {
    const chip = e.target.closest('.chip');
    if (!chip) return;
    
    chips.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
    chip.classList.add('active');
    currentLangPair = chip.dataset.pair;
    selectedLangLabel.textContent = currentLangPair;
    saveSettings();
    closeLangModal();
  });

  themeLightBtn.addEventListener('click', () => {
    applyTheme('light');
    saveTheme('light');
    messageInput.focus();
  });

  themeDarkBtn.addEventListener('click', () => {
    applyTheme('dark');
    saveTheme('dark');
    messageInput.focus();
  });

  modal.addEventListener('click', e => { if (e.target === modal) closeLangModal(); });
  document.addEventListener('keydown', e => { 
    if (e.key === 'Escape' && modal.style.display === 'flex') closeLangModal();
    
    // Space key for voice mode
    if (e.code === 'Space' && isVoiceMode && isRecording && e.target !== messageInput) {
      e.preventDefault();
      stopRecording();
    }
  });

  // New input handlers
  messageInput.addEventListener('input', () => {
    autoResizeTextarea();
    updateSendButton();
    
    // If typing while in voice mode, deactivate voice mode
    if (isVoiceMode && messageInput.value.trim().length > 0) {
      stopVoiceMode();
    }
  });

  messageInput.addEventListener('keydown', async e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (!sendBtn.disabled && !sendBtn.classList.contains('hidden')) {
        await handleSubmit();
      }
    }
  });

  sendBtn.addEventListener('click', async () => {
    const hasText = messageInput.value.trim().length > 0;
    
    if (hasText) {
      await handleSubmit();
    }
  });

  micBtn.addEventListener('click', startRecording);
  voiceModeBtn.addEventListener('click', toggleVoiceMode);

  // Handle submit function
  async function handleSubmit() {
    const text = messageInput.value.trim();
    if (!text) return;
    
    const humanMessage = addMessage(text, true);
    
    // Clear input
    messageInput.value = '';
    autoResizeTextarea();
    updateSendButton();
    
    chatHistory.scrollTop = chatHistory.scrollHeight;
    
    const translationData = await translateText(text, currentLangPair);
    const aiMessage = addMessage(translationData.translation, false, false, translationData.target_language);
    
    chatHistory.scrollTop = chatHistory.scrollHeight;
  }

  window.addEventListener('DOMContentLoaded', () => {
    loadSettings();
    messageInput.focus();
    updateSendButton();
  });

  document.addEventListener('click', e => {
    if (modal.style.display !== 'flex' &&
        !e.target.closest('button') &&
        !e.target.closest('input') &&
        !e.target.closest('textarea') &&
        !e.target.closest('select') &&
        !e.target.closest('.chip') &&
        e.target !== messageInput) {
      messageInput.focus();
    }
  });

  async function playTTS(text, language, button) {
    console.log('playTTS called:', { text: text.substring(0, 50), language });
    
    try {
      // Stop any currently playing audio
      if (currentlyPlayingAudio) {
        currentlyPlayingAudio.pause();
        currentlyPlayingAudio.currentTime = 0;
        if (currentlyPlayingButton) {
          currentlyPlayingButton.classList.remove('playing');
          currentlyPlayingButton.textContent = 'ðŸ”Š';
        }
      }

      // If clicking the same button that was playing, just stop
      if (currentlyPlayingButton === button && button.classList.contains('playing')) {
        currentlyPlayingButton = null;
        currentlyPlayingAudio = null;
        return;
      }

      // Set loading state
      button.classList.add('loading');
      button.textContent = 'â³';

      // Make TTS request
      const response = await fetch(`${API_BASE}/tts`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          text: text,
          language: language
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`TTS failed: ${errorData.error || response.statusText}`);
      }

      // Get audio blob
      const audioBlob = await response.blob();
      console.log('Received audio blob, size:', audioBlob.size);

      if (audioBlob.size === 0) {
        throw new Error('Received empty audio data');
      }

      // Create audio URL and play
      const audioUrl = URL.createObjectURL(audioBlob);
      const audio = new Audio(audioUrl);

      // Set up audio event listeners
      audio.onloadeddata = () => {
        console.log('Audio loaded, duration:', audio.duration);
      };

      audio.onplay = () => {
        console.log('Audio playback started');
        button.classList.remove('loading');
        button.classList.add('playing');
        button.textContent = 'â¸ï¸';
        currentlyPlayingAudio = audio;
        currentlyPlayingButton = button;
      };

      audio.onended = () => {
        console.log('Audio playback ended');
        button.classList.remove('playing');
        button.textContent = 'ðŸ”Š';
        URL.revokeObjectURL(audioUrl);
        currentlyPlayingAudio = null;
        currentlyPlayingButton = null;
        
        // If in voice mode, start recording again after TTS finishes
        if (isVoiceMode && voiceModeActive) {
          setTimeout(() => {
            startRecording();
          }, 500);
        }
      };

      audio.onerror = (e) => {
        console.error('Audio playback error:', e);
        button.classList.remove('loading', 'playing');
        button.textContent = 'ðŸ”Š';
        URL.revokeObjectURL(audioUrl);
        showStatus('Audio playback failed');
      };

      // Start playing
      await audio.play();

    } catch (error) {
      console.error('TTS error:', error);
      button.classList.remove('loading', 'playing');
      button.textContent = 'ðŸ”Š';
      showStatus(`TTS error: ${error.message}`);
    }
  }

  async function startRecording() {
    console.log('startRecording called, isRecording:', isRecording);
    
    if (isRecording) {
      stopRecording();
      return;
    }
    
    try {
      // Request microphone access with proper settings
      console.log('Requesting microphone access...');
      mediaStream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          sampleRate: 16000
        } 
      });
      
      console.log('Microphone access granted, stream tracks:', mediaStream.getTracks().length);
      
      // Clear previous audio chunks
      audioChunks = [];
      
      // Try different MIME types in order of preference
      let mimeType = null;
      const typesToTry = [
        'audio/webm;codecs=opus',
        'audio/webm',
        'audio/ogg;codecs=opus',
        'audio/ogg',
        'audio/mp4',
        'audio/wav'
      ];
      
      for (const type of typesToTry) {
        if (MediaRecorder.isTypeSupported(type)) {
          mimeType = type;
          break;
        }
      }
      
      console.log('Using MIME type:', mimeType || 'browser default');
      
      // Create MediaRecorder with proper options
      const options = {};
      if (mimeType) options.mimeType = mimeType;
      
      mediaRecorder = new MediaRecorder(mediaStream, options);
      
      console.log('MediaRecorder created successfully');
      
      // Set up event handlers BEFORE starting
      mediaRecorder.ondataavailable = (event) => {
        console.log('Data available - size:', event.data.size, 'bytes, type:', event.data.type);
        if (event.data && event.data.size > 0) {
          audioChunks.push(event.data);
          console.log('Added chunk, total chunks:', audioChunks.length);
        } else {
          console.warn('Received empty data chunk');
        }
      };
      
      mediaRecorder.onstop = () => {
        console.log('MediaRecorder stopped, processing audio...');
        processRecordedAudio();
      };
      
      mediaRecorder.onerror = (event) => {
        console.error('MediaRecorder error:', event.error);
        showStatus('Recording error: ' + event.error.message);
        resetRecordingState();
      };
      
      mediaRecorder.onstart = () => {
        console.log('MediaRecorder started successfully');
      };
      
      // Start recording
      console.log('Starting MediaRecorder...');
      mediaRecorder.start();
      
      // Update UI
      isRecording = true;
      micBtn.classList.add('recording');
      if (isVoiceMode) {
        showStatus('Voice mode: Speaking... Press space or click to stop');
      } else {
        showStatus('Recording... Click to stop');
      }
      
      console.log('Recording initialization complete');
      
    } catch (error) {
      console.error('Error starting recording:', error);
      showStatus('Could not access microphone: ' + error.message);
      resetRecordingState();
    }
  }

  function stopRecording() {
    console.log('stopRecording called');
    
    if (!isRecording || !mediaRecorder) {
      console.log('Not recording or no mediaRecorder');
      return;
    }
    
    console.log('Stopping MediaRecorder, current state:', mediaRecorder.state);
    
    if (mediaRecorder.state === 'recording') {
      mediaRecorder.stop();
    }
    
    // Update UI immediately
    isRecording = false;
    micBtn.classList.remove('recording');
    showStatus('Processing audio...');
  }

  function processRecordedAudio() {
    console.log('processRecordedAudio called');
    console.log('Audio chunks:', audioChunks.length);
    
    if (audioChunks.length === 0) {
      console.error('No audio chunks available');
      showStatus('No audio data recorded - please speak during recording');
      resetRecordingState();
      return;
    }
    
    // Calculate total size
    const totalSize = audioChunks.reduce((sum, chunk) => sum + chunk.size, 0);
    console.log('Total audio size:', totalSize, 'bytes');
    
    if (totalSize === 0) {
      console.error('Total audio size is 0');
      showStatus('No audio detected - please speak louder');
      resetRecordingState();
      return;
    }
    
    // Use the actual mimeType from the recorder, with fallback
    let mimeType = mediaRecorder.mimeType;
    if (!mimeType) {
      mimeType = 'audio/webm';
    }
    
    console.log('Creating blob with MIME type:', mimeType);
    
    // Create blob from chunks
    const audioBlob = new Blob(audioChunks, { type: mimeType });
    
    console.log('Created audio blob:');
    console.log('- Size:', audioBlob.size, 'bytes');
    console.log('- Type:', audioBlob.type);
    
    // Validate the blob before sending
    if (audioBlob.size === 0) {
      console.error('Created blob is empty despite having chunks');
      showStatus('Audio processing failed - blob is empty');
      resetRecordingState();
      return;
    }
    
    // Send to server
    sendAudioToServer(audioBlob);
  }

  async function sendAudioToServer(audioBlob) {
    try {
      console.log('Sending audio to server, blob size:', audioBlob.size);
      
      const formData = new FormData();
      formData.append('audio', audioBlob, 'recording.webm');
      formData.append('language_pair', currentLangPair);
      
      console.log('FormData created, sending request...');
      
      const response = await fetch(`${API_BASE}/transcribe`, {
        method: 'POST',
        body: formData
      });
      
      console.log('Server response status:', response.status);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Server error:', response.status, errorText);
        throw new Error(`Server error ${response.status}: ${errorText}`);
      }
      
      const result = await response.json();
      console.log('Transcription result:', result);
      
      // Add transcribed message
      const humanMessage = addMessage(result.transcribed_text, true, true);
      
      // Add translation with play button
      const aiMessage = addMessage(result.translation, false, false, result.target_language);
      
      // In voice mode, automatically play the translation
      if (isVoiceMode && voiceModeActive) {
        const playButton = aiMessage.querySelector('.play-btn');
        if (playButton) {
          setTimeout(() => {
            playTTS(result.translation, result.target_language, playButton);
          }, 500);
        }
      }
      
      chatHistory.scrollTop = chatHistory.scrollHeight;
      
      showStatus('Audio transcribed and translated!');
      
    } catch (error) {
      console.error('Error sending audio to server:', error);
      showStatus('Transcription failed: ' + error.message);
    } finally {
      resetRecordingState();
    }
  }

  function resetRecordingState() {
    console.log('resetRecordingState called');
    
    // Stop media stream
    if (mediaStream) {
      mediaStream.getTracks().forEach(track => {
        console.log('Stopping track:', track.kind, track.label);
        track.stop();
      });
      mediaStream = null;
    }
    
    // Reset MediaRecorder
    mediaRecorder = null;
    
    // Clear audio chunks
    audioChunks = [];
    
    // Reset state
    isRecording = false;
    
    // Reset UI
    micBtn.classList.remove('recording');
  }

  async function translateText(text, languagePair) {
    try {
      const res = await fetch(`${API_BASE}/translate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          text: text, 
          language_pair: languagePair
        })
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      
      console.log(`Auto-detected direction: ${data.direction_used}`);
      
      return data;
    } catch (e) {
      console.error(e);
      return { translation: `Translation error: ${e.message}`, target_language: 'en' };
    }
  }

  function addMessage(text, isHuman = true, isTranscribed = false, targetLanguage = null) {
    const el = document.createElement('div');
    el.className = `message ${isHuman ? 'from-human' : 'from-ai'}`;
    if (isTranscribed) {
      el.classList.add('transcribed');
    }
    
    // Create message content
    const contentEl = document.createElement('div');
    contentEl.className = 'message-content';
    contentEl.textContent = text;
    el.appendChild(contentEl);
    
    // Add actions for AI messages (translations)
    if (!isHuman && targetLanguage) {
      const actionsEl = document.createElement('div');
      actionsEl.className = 'message-actions';
      
      const playBtn = document.createElement('button');
      playBtn.className = 'play-btn';
      playBtn.textContent = 'ðŸ”Š';
      playBtn.title = 'Play audio';
      playBtn.addEventListener('click', () => {
        playTTS(text, targetLanguage, playBtn);
      });
      
      actionsEl.appendChild(playBtn);
      el.appendChild(actionsEl);
    }
    
    // Remove welcome message if it exists
    const welcomeMsg = chatHistory.querySelector('.welcome-message');
    if (welcomeMsg) {
      welcomeMsg.remove();
    }
    
    chatHistory.appendChild(el);
    chatHistory.scrollTop = chatHistory.scrollHeight;
    
    return el;
  }
</script>

</body>
</html>