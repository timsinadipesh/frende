<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>frende</title>
<style>
  :root {
    --bg-color: #ffffff;
    --text-color: #000000;
    --panel-bg: #f8f8f8;
    --message-human: rgba(0,0,0,0.1);
    --message-ai: rgba(0,0,0,0.05);
    --accent-color: #2196f3;
    --recording-color: #f44336;
    --success-color: #4caf50;
  }
  [data-theme="dark"] {
    --bg-color: #121212;
    --text-color: #ffffff;
    --panel-bg: #1e1e1e;
    --message-human: rgba(255,255,255,0.25);
    --message-ai: rgba(0,0,0,0.25);
    --accent-color: #64b5f6;
    --recording-color: #ef5350;
    --success-color: #66bb6a;
  }

  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: sans-serif;
    height: 100vh;
    display: flex;
    flex-direction: column;
    background: var(--bg-color);
    color: var(--text-color);
  }

  .top-bar {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    gap: 12px;
    padding: 12px;
    background: var(--panel-bg);
  }
  .left-group {
    display: flex;
    align-items: center;
    gap: 10px;
    justify-self: start;
  }
  .brand {
    font-weight: 700;
    font-size: 1.25rem;
    letter-spacing: .4px;
    justify-self: center;
    user-select: none;
  }
  .right-group { 
    justify-self: end; 
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .lang-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 8px 12px;
    border-radius: 8px;
    border: 1px solid rgba(0,0,0,0.1);
    cursor: pointer;
    background: var(--bg-color);
    color: var(--text-color);
    transition: all .15s ease;
    font-weight: 600;
    letter-spacing: .3px;
    white-space: nowrap;
    position: relative;
  }
  .lang-btn:hover { 
    background: rgba(0,0,0,0.05);
    border-color: rgba(0,0,0,0.2);
  }

  .theme-toggle {
    display: flex;
    gap: 2px;
    background: var(--panel-bg);
    border-radius: 6px;
    padding: 2px;
    border: 1px solid rgba(0,0,0,0.1);
  }

  .theme-btn {
    padding: 4px 8px;
    border: none;
    background: transparent;
    color: var(--text-color);
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.8rem;
    font-weight: 500;
    transition: all .15s ease;
  }

  .theme-btn.active {
    background: var(--bg-color);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }

  .theme-btn:hover:not(.active) {
    background: rgba(0,0,0,0.05);
  }

  .main { flex: 1; display: flex; overflow: hidden; }
  .panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 10px;
    overflow-y: auto;
    background: var(--bg-color);
    align-items: center;
    position: relative;
  }
  .divider { 
    width: 1px; 
    background: rgba(0,0,0,0.1); 
    position: relative;
  }

  .audio-btn {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 10;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: 2px solid var(--accent-color);
    background: var(--bg-color);
    color: var(--accent-color);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    transition: all .2s ease;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }

  .audio-btn:hover {
    transform: translate(-50%, -50%) scale(1.05);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  }

  .audio-btn.recording {
    border-color: var(--recording-color);
    color: var(--recording-color);
    animation: pulse 1.5s infinite;
  }

  .audio-btn.processing {
    border-color: var(--accent-color);
    color: var(--accent-color);
    animation: spin 1s linear infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }

  @keyframes spin {
    from { transform: translate(-50%, -50%) rotate(0deg); }
    to { transform: translate(-50%, -50%) rotate(360deg); }
  }

  .message {
    padding: 8px 12px;
    margin: 4px 0;
    border-radius: 16px;
    max-width: 80%;
    line-height: 1.4;
    position: relative;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .message-content {
    flex: 1;
  }
  
  .message-actions {
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity .2s ease;
  }
  
  .message:hover .message-actions {
    opacity: 1;
  }
  
  .from-human { background: var(--message-human); }
  .from-ai { background: var(--message-ai); }

  .message.transcribed {
    border-left: 3px solid var(--accent-color);
    padding-left: 15px;
  }

  .play-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: 1px solid var(--accent-color);
    background: var(--bg-color);
    color: var(--accent-color);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    transition: all .2s ease;
    flex-shrink: 0;
  }

  .play-btn:hover {
    background: var(--accent-color);
    color: var(--bg-color);
    transform: scale(1.1);
  }

  .play-btn.playing {
    background: var(--success-color);
    border-color: var(--success-color);
    color: white;
    animation: pulse-play 1s infinite;
  }

  .play-btn.loading {
    animation: spin 1s linear infinite;
  }

  @keyframes pulse-play {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  #typing-area {
    text-align: left;
    padding: 10px;
    outline: none;
    border: none;
    background: transparent;
    color: var(--text-color);
    font-size: 1.1rem;
    min-height: 30px;
    white-space: pre-wrap;
    word-break: break-word;
    width: 100%;
    max-width: 80%;
  }

  .spacer {
    width: 100%;
    max-width: 80%;
  }

  .modal {
    position: fixed;
    inset: 0;
    z-index: 1000;
    background: rgba(0,0,0,0.35);
    display: none;
    align-items: center;
    justify-content: center;
  }
  .card {
    width: min(280px, 92vw);
    background: #ffffff;
    color: #000;
    border-radius: 16px;
    padding: 18px 16px;
    box-shadow: 0 18px 60px rgba(0,0,0,0.25);
  }
  .chips {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .chip {
    padding: 12px 16px;
    text-align: center;
    border-radius: 12px;
    background: #f2f5fb;
    border: 1px solid #e4eaf2;
    cursor: pointer;
    user-select: none;
    font-weight: 600;
    color: #102038;
    transition: background .15s ease, border-color .15s ease, color .15s ease;
  }
  .chip:hover {
    background: #e3e9f3;
    border-color: #c5d1e4;
  }
  .chip.active {
    background: #bbdefb;
    border-color: #2196f3;
    color: #0d47a1;
  }

  .status {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: var(--panel-bg);
    color: var(--text-color);
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 0.9rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    opacity: 0;
    transition: opacity .3s ease;
    z-index: 100;
  }

  .status.show {
    opacity: 1;
  }
</style>
</head>
<body>

  <div class="top-bar">
    <div class="left-group">
      <button id="lang-btn" class="lang-btn" title="Select Language" aria-label="Select Language">
        <span id="selected-lang">EN → DE</span>
      </button>
    </div>
    <div class="brand">frende</div>
    <div class="right-group">
      <div class="theme-toggle">
        <button id="theme-light" class="theme-btn">Light</button>
        <button id="theme-dark" class="theme-btn">Dark</button>
      </div>
    </div>
  </div>

  <div class="main">
    <div class="panel" id="left-panel">
      <div id="typing-area" contenteditable="true"></div>
    </div>
    <div class="divider">
      <button id="audio-btn" class="audio-btn" title="Record Audio" aria-label="Record Audio">
        🎤
      </button>
    </div>
    <div class="panel" id="right-panel"></div>
  </div>

  <div id="lang-modal" class="modal">
    <div class="card">
      <div class="chips" id="lang-chips">
        <div class="chip" data-pair="EN → DE">EN → DE</div>
        <div class="chip" data-pair="DE → FR">DE → FR</div>
        <div class="chip" data-pair="FR → EN">FR → EN</div>
      </div>
    </div>
  </div>

  <div id="status" class="status"></div>

<script>
  const typingArea = document.getElementById('typing-area');
  const leftPanel = document.getElementById('left-panel');
  const rightPanel = document.getElementById('right-panel');
  const langBtn = document.getElementById('lang-btn');
  const selectedLangLabel = document.getElementById('selected-lang');
  const modal = document.getElementById('lang-modal');
  const chips = document.getElementById('lang-chips');
  const themeLightBtn = document.getElementById('theme-light');
  const themeDarkBtn = document.getElementById('theme-dark');
  const audioBtn = document.getElementById('audio-btn');
  const status = document.getElementById('status');

  const API_BASE = 'http://localhost:5000';

  const LANGUAGE_PAIRS = {
    'EN → DE': 'EN → DE',
    'DE → FR': 'DE → FR', 
    'FR → EN': 'FR → EN'
  };

  let currentLangPair = 'EN → DE';
  let mediaRecorder = null;
  let audioChunks = [];
  let isRecording = false;
  let mediaStream = null;
  let currentlyPlayingAudio = null;
  let currentlyPlayingButton = null;

  function showStatus(message) {
    status.textContent = message;
    status.classList.add('show');
    setTimeout(() => {
      status.classList.remove('show');
    }, 3000);
  }

  function getSystemTheme() {
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  }

  function applyTheme(theme) {
    document.documentElement.dataset.theme = theme;
    themeLightBtn.classList.toggle('active', theme === 'light');
    themeDarkBtn.classList.toggle('active', theme === 'dark');
  }

  function loadSettings() {
    const savedLang = localStorage.getItem('langPair');
    const savedTheme = localStorage.getItem('theme');

    if (savedLang && LANGUAGE_PAIRS[savedLang]) {
      currentLangPair = savedLang;
    }
    selectedLangLabel.textContent = currentLangPair;

    const themeToApply = savedTheme || getSystemTheme();
    applyTheme(themeToApply);

    chips.querySelectorAll('.chip').forEach(chip => {
      chip.classList.toggle('active', chip.dataset.pair === currentLangPair);
    });
  }

  function saveSettings() {
    localStorage.setItem('langPair', currentLangPair);
  }

  function saveTheme(theme) {
    localStorage.setItem('theme', theme);
  }

  function openLangModal() { modal.style.display = 'flex'; }
  function closeLangModal() { 
    modal.style.display = 'none'; 
    typingArea.focus(); 
  }

  langBtn.addEventListener('click', openLangModal);

  chips.addEventListener('click', e => {
    const chip = e.target.closest('.chip');
    if (!chip) return;
    
    chips.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
    chip.classList.add('active');
    currentLangPair = chip.dataset.pair;
    selectedLangLabel.textContent = currentLangPair;
    saveSettings();
    closeLangModal();
  });

  themeLightBtn.addEventListener('click', () => {
    applyTheme('light');
    saveTheme('light');
    typingArea.focus();
  });

  themeDarkBtn.addEventListener('click', () => {
    applyTheme('dark');
    saveTheme('dark');
    typingArea.focus();
  });

  modal.addEventListener('click', e => { if (e.target === modal) closeLangModal(); });
  document.addEventListener('keydown', e => { if (e.key === 'Escape' && modal.style.display === 'flex') closeLangModal(); });

  window.addEventListener('DOMContentLoaded', () => {
    loadSettings();
    typingArea.focus();
  });

  leftPanel.addEventListener('scroll', () => {
    rightPanel.scrollTop = leftPanel.scrollTop;
  });
  rightPanel.addEventListener('scroll', () => {
    leftPanel.scrollTop = rightPanel.scrollTop;
  });

  document.addEventListener('click', e => {
    if (modal.style.display !== 'flex' &&
        !e.target.closest('button') &&
        !e.target.closest('input') &&
        !e.target.closest('select') &&
        !e.target.closest('.chip') &&
        e.target !== typingArea) {
      typingArea.focus();
    }
  });

  async function playTTS(text, language, button) {
    console.log('playTTS called:', { text: text.substring(0, 50), language });
    
    try {
      // Stop any currently playing audio
      if (currentlyPlayingAudio) {
        currentlyPlayingAudio.pause();
        currentlyPlayingAudio.currentTime = 0;
        if (currentlyPlayingButton) {
          currentlyPlayingButton.classList.remove('playing');
          currentlyPlayingButton.textContent = '🔊';
        }
      }

      // If clicking the same button that was playing, just stop
      if (currentlyPlayingButton === button && button.classList.contains('playing')) {
        currentlyPlayingButton = null;
        currentlyPlayingAudio = null;
        return;
      }

      // Set loading state
      button.classList.add('loading');
      button.textContent = '⏳';

      // Make TTS request
      const response = await fetch(`${API_BASE}/tts`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          text: text,
          language: language
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`TTS failed: ${errorData.error || response.statusText}`);
      }

      // Get audio blob
      const audioBlob = await response.blob();
      console.log('Received audio blob, size:', audioBlob.size);

      if (audioBlob.size === 0) {
        throw new Error('Received empty audio data');
      }

      // Create audio URL and play
      const audioUrl = URL.createObjectURL(audioBlob);
      const audio = new Audio(audioUrl);

      // Set up audio event listeners
      audio.onloadeddata = () => {
        console.log('Audio loaded, duration:', audio.duration);
      };

      audio.onplay = () => {
        console.log('Audio playback started');
        button.classList.remove('loading');
        button.classList.add('playing');
        button.textContent = '⏸';
        currentlyPlayingAudio = audio;
        currentlyPlayingButton = button;
      };

      audio.onended = () => {
        console.log('Audio playback ended');
        button.classList.remove('playing');
        button.textContent = '🔊';
        URL.revokeObjectURL(audioUrl);
        currentlyPlayingAudio = null;
        currentlyPlayingButton = null;
      };

      audio.onerror = (e) => {
        console.error('Audio playback error:', e);
        button.classList.remove('loading', 'playing');
        button.textContent = '🔊';
        URL.revokeObjectURL(audioUrl);
        showStatus('Audio playback failed');
      };

      // Start playing
      await audio.play();

    } catch (error) {
      console.error('TTS error:', error);
      button.classList.remove('loading', 'playing');
      button.textContent = '🔊';
      showStatus(`TTS error: ${error.message}`);
    }
  }

  async function startRecording() {
    console.log('startRecording called, isRecording:', isRecording);
    
    if (isRecording) {
      stopRecording();
      return;
    }
    
    try {
      // Request microphone access with proper settings
      console.log('Requesting microphone access...');
      mediaStream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          sampleRate: 16000 // Use 16kHz as it's standard for speech recognition
        } 
      });
      
      console.log('Microphone access granted, stream tracks:', mediaStream.getTracks().length);
      
      // Clear previous audio chunks
      audioChunks = [];
      
      // Try different MIME types in order of preference
      let mimeType = null;
      const typesToTry = [
        'audio/webm;codecs=opus',
        'audio/webm',
        'audio/ogg;codecs=opus',
        'audio/ogg',
        'audio/mp4',
        'audio/wav'
      ];
      
      for (const type of typesToTry) {
        if (MediaRecorder.isTypeSupported(type)) {
          mimeType = type;
          break;
        }
      }
      
      console.log('Using MIME type:', mimeType || 'browser default');
      
      // Create MediaRecorder with proper options
      const options = {};
      if (mimeType) options.mimeType = mimeType;
      
      mediaRecorder = new MediaRecorder(mediaStream, options);
      
      console.log('MediaRecorder created successfully');
      console.log('MediaRecorder state:', mediaRecorder.state);
      console.log('MediaRecorder mimeType:', mediaRecorder.mimeType);
      
      // Set up event handlers BEFORE starting
      mediaRecorder.ondataavailable = (event) => {
        console.log('Data available - size:', event.data.size, 'bytes, type:', event.data.type);
        if (event.data && event.data.size > 0) {
          audioChunks.push(event.data);
          console.log('Added chunk, total chunks:', audioChunks.length);
        } else {
          console.warn('Received empty data chunk');
        }
      };
      
      mediaRecorder.onstop = () => {
        console.log('MediaRecorder stopped, processing audio...');
        processRecordedAudio();
      };
      
      mediaRecorder.onerror = (event) => {
        console.error('MediaRecorder error:', event.error);
        showStatus('Recording error: ' + event.error.message);
        resetRecordingState();
      };
      
      mediaRecorder.onstart = () => {
        console.log('MediaRecorder started successfully');
      };
      
      // Start recording with NO interval parameter to get all data in one chunk
      console.log('Starting MediaRecorder...');
      mediaRecorder.start(); // Don't specify interval - let it collect all data
      
      // Update UI
      isRecording = true;
      audioBtn.classList.add('recording');
      audioBtn.textContent = '⏹';
      audioBtn.title = 'Stop Recording';
      showStatus('Recording... Click to stop');
      
      console.log('Recording initialization complete');
      
    } catch (error) {
      console.error('Error starting recording:', error);
      showStatus('Could not access microphone: ' + error.message);
      resetRecordingState();
    }
  }

  function stopRecording() {
    console.log('stopRecording called');
    
    if (!isRecording || !mediaRecorder) {
      console.log('Not recording or no mediaRecorder');
      return;
    }
    
    console.log('Stopping MediaRecorder, current state:', mediaRecorder.state);
    
    if (mediaRecorder.state === 'recording') {
      mediaRecorder.stop();
    }
    
    // Update UI immediately
    isRecording = false;
    audioBtn.classList.remove('recording');
    audioBtn.classList.add('processing');
    audioBtn.textContent = '⏳';
    audioBtn.title = 'Processing...';
    showStatus('Processing audio...');
  }

  function processRecordedAudio() {
    console.log('processRecordedAudio called');
    console.log('Audio chunks:', audioChunks.length);
    
    if (audioChunks.length === 0) {
      console.error('No audio chunks available');
      showStatus('No audio data recorded - please speak during recording');
      resetRecordingState();
      return;
    }
    
    // Calculate total size
    const totalSize = audioChunks.reduce((sum, chunk) => sum + chunk.size, 0);
    console.log('Total audio size:', totalSize, 'bytes');
    
    if (totalSize === 0) {
      console.error('Total audio size is 0');
      showStatus('No audio detected - please speak louder');
      resetRecordingState();
      return;
    }
    
    // Use the actual mimeType from the recorder, with fallback
    let mimeType = mediaRecorder.mimeType;
    if (!mimeType) {
      mimeType = 'audio/webm'; // Default fallback
    }
    
    console.log('Creating blob with MIME type:', mimeType);
    
    // Create blob from chunks
    const audioBlob = new Blob(audioChunks, { type: mimeType });
    
    console.log('Created audio blob:');
    console.log('- Size:', audioBlob.size, 'bytes');
    console.log('- Type:', audioBlob.type);
    console.log('- Chunks used:', audioChunks.length);
    
    // Validate the blob before sending
    if (audioBlob.size === 0) {
      console.error('Created blob is empty despite having chunks');
      showStatus('Audio processing failed - blob is empty');
      resetRecordingState();
      return;
    }
    
    // Send to server
    sendAudioToServer(audioBlob);
  }

  async function sendAudioToServer(audioBlob) {
    try {
      console.log('Sending audio to server, blob size:', audioBlob.size);
      
      const formData = new FormData();
      formData.append('audio', audioBlob, 'recording.webm');
      formData.append('language_pair', currentLangPair);
      
      console.log('FormData created, sending request...');
      
      const response = await fetch(`${API_BASE}/transcribe`, {
        method: 'POST',
        body: formData
      });
      
      console.log('Server response status:', response.status);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Server error:', response.status, errorText);
        throw new Error(`Server error ${response.status}: ${errorText}`);
      }
      
      const result = await response.json();
      console.log('Transcription result:', result);
      
      // Add transcribed message to left panel
      const humanMessage = addMessage(result.transcribed_text, true, true);
      leftPanel.insertBefore(humanMessage, typingArea);
      leftPanel.scrollTop = leftPanel.scrollHeight;
      
      // Add translation to right panel with play button
      const aiMessage = addMessage(result.translation, false, false, result.target_language);
      rightPanel.appendChild(aiMessage);
      
      // Balance heights
      const hLeft = humanMessage.offsetHeight;
      const hRight = aiMessage.offsetHeight;
      if (hLeft > hRight) {
        const spacer = createSpacer(hLeft - hRight);
        rightPanel.appendChild(spacer);
      } else if (hRight > hLeft) {
        const spacer = createSpacer(hRight - hLeft);
        leftPanel.insertBefore(spacer, typingArea);
      }
      
      // Sync scroll
      leftPanel.scrollTop = leftPanel.scrollHeight;
      rightPanel.scrollTop = rightPanel.scrollHeight;
      
      showStatus('Audio transcribed and translated!');
      
    } catch (error) {
      console.error('Error sending audio to server:', error);
      showStatus('Transcription failed: ' + error.message);
    } finally {
      resetRecordingState();
    }
  }

  function resetRecordingState() {
    console.log('resetRecordingState called');
    
    // Stop media stream
    if (mediaStream) {
      mediaStream.getTracks().forEach(track => {
        console.log('Stopping track:', track.kind, track.label);
        track.stop();
      });
      mediaStream = null;
    }
    
    // Reset MediaRecorder
    mediaRecorder = null;
    
    // Clear audio chunks
    audioChunks = [];
    
    // Reset state
    isRecording = false;
    
    // Reset UI
    audioBtn.classList.remove('recording', 'processing');
    audioBtn.textContent = '🎤';
    audioBtn.title = 'Record Audio';
  }

  // Event listener for the audio button
  audioBtn.addEventListener('click', startRecording);

  async function translateText(text, languagePair) {
    try {
      const res = await fetch(`${API_BASE}/translate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          text: text, 
          language_pair: languagePair
        })
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      
      console.log(`Auto-detected direction: ${data.direction_used}`);
      
      return data;
    } catch (e) {
      console.error(e);
      return { translation: `Translation error: ${e.message}`, target_language: 'en' };
    }
  }

  function createSpacer(height) {
    const spacer = document.createElement('div');
    spacer.className = 'spacer';
    spacer.style.height = `${height}px`;
    return spacer;
  }

  function addMessage(text, isHuman = true, isTranscribed = false, targetLanguage = null) {
    const el = document.createElement('div');
    el.className = `message ${isHuman ? 'from-human' : 'from-ai'}`;
    if (isTranscribed) {
      el.classList.add('transcribed');
    }
    
    // Create message content
    const contentEl = document.createElement('div');
    contentEl.className = 'message-content';
    contentEl.textContent = text;
    el.appendChild(contentEl);
    
    // Add actions for AI messages (translations)
    if (!isHuman && targetLanguage) {
      const actionsEl = document.createElement('div');
      actionsEl.className = 'message-actions';
      
      const playBtn = document.createElement('button');
      playBtn.className = 'play-btn';
      playBtn.textContent = '🔊';
      playBtn.title = 'Play audio';
      playBtn.addEventListener('click', () => {
        playTTS(text, targetLanguage, playBtn);
      });
      
      actionsEl.appendChild(playBtn);
      el.appendChild(actionsEl);
    }
    
    return el;
  }

  typingArea.addEventListener('keydown', async e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      const text = typingArea.innerText.trim();
      if (!text) return;
      
      const humanMessage = addMessage(text, true);
      leftPanel.insertBefore(humanMessage, typingArea);
      typingArea.innerText = '';
      leftPanel.scrollTop = leftPanel.scrollHeight;
      rightPanel.scrollTop = rightPanel.scrollHeight;
      
      const translationData = await translateText(text, currentLangPair);
      const aiMessage = addMessage(translationData.translation, false, false, translationData.target_language);
      rightPanel.appendChild(aiMessage);
      
      const hLeft = humanMessage.offsetHeight;
      const hRight = aiMessage.offsetHeight;
      if (hLeft > hRight) {
        const spacer = createSpacer(hLeft - hRight);
        rightPanel.appendChild(spacer);
      } else if (hRight > hLeft) {
        const spacer = createSpacer(hRight - hLeft);
        leftPanel.insertBefore(spacer, typingArea);
      }
      
      leftPanel.scrollTop = leftPanel.scrollHeight;
      rightPanel.scrollTop = rightPanel.scrollHeight;
    }
  });
</script>

</body>
</html>